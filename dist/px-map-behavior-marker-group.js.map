{"version":3,"sources":["px-map-behavior-marker-group.es6.js"],"names":["window","PxMapBehavior","MarkerGroupImpl","properties","name","type","String","notify","data","Object","observer","_colorsByType","value","colorsByType","iconFns","cluster","undefined","marker","clusterConfig","update","elementInst","getInstOptions","features","_syncDataWithMarkers","_notifyNewFeatures","redraw","_clearAllMarkersAndData","addInst","parent","spiderifyFn","_handleClusterSpiderify","bind","unspiderifyFn","_handleClusterUnspiderify","markerTapFn","_handleSingleMarkerTap","markerDoubleClickFn","_handleSingleMarkerDoubleClick","clusterTapFn","_handleClusterTap","bindEvents","LayerImpl","call","async","fire","removeInst","createInst","options","L","markerClusterGroup","updateInst","lastOptions","nextOptions","defaultOptions","showCoverageOnHover","maxClusterRadius","spiderifyOnMaxZoom","removeOutsideVisibleBounds","animate","polygonOptions","stroke","color","getComputedStyleValue","fillColor","fillOpacity","assign","_getValidData","iconCreateFunction","_createClusterIcon","featureSet","Set","size","_notifyNewFeaturesDebounce","bounds","latLngBounds","feature","extend","geometry","coordinates","dataIsNotValid","Array","isArray","length","console","log","is","created","updateFn","updateStyles","_handleStylesUpdated","_updateStylesFn","_calculateColorsByType","markers","getAllChildMarkers","count","types","_indexClusterMarkersByType","colors","containerSize","_getClusterIconSize","pathSize","_getStyleValueAsNum","borderSize","countByType","styleScope","isShadyScoped","getShadyScope","PxMap","ClusterIcon","publicColorsByType","newColorsByType","_getAllIconColors","lastColorsByTypeStringified","JSON","stringify","info","warning","important","unknown","customColor","i","styleValName","__styleVals","computedVal","indexOf","valWithoutSuffix","replace","valAsNum","Math","floor","reduce","featureProperties","clusterInst","clearLayers","_features","_markers","newFeatures","featuresSet","markersMap","WeakMap","_diffNewFeatures","featuresToAdd","featuresToUpdate","featuresToRemove","nextFeaturesSet","nextMarkersMap","cachedMarker","markersToOperate","get","_createMarker","push","set","addLayers","_updateMarker","refreshClusters","delete","removeLayers","clear","lastFeatureSet","markerMap","len","valid","known","featureHash","id","has","add","hash","lat","lng","iconSettings","_extractMarkerIconSettings","base","icon","_createMarkerIcon","setIcon","getLatLng","nextLng","nextLat","Number","setLatLng","featSettings","featSettingsKeys","keys","featKeyCamelized","substring","match","charAt","toUpperCase","klassName","_strToKlassName","str","evt","_icon","style","visibility","layer","LatLng","latLng","detail","hasOwnProperty","_bindAndOpenPopup","getBounds","bindPopup","openPopup","popupSettings","_featSettingsToProps","_Base","popup","__boundCloseFn","_unbindAndClosePopup","on","getPopup","off","closePopup","unbindPopup","settings","prefix","settingsAsProps","newKey","substr","test","MarkerGroup","Layer"],"mappings":"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","file":"px-map-behavior-marker-group.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2018, General Electric\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function() {\n  'use strict';\n\n  /****************************************************************************\n   * BEHAVIORS\n   ****************************************************************************/\n\n  /* Ensures the behavior namespace is created */\n  window.PxMapBehavior = (window.PxMapBehavior || {});\n\n  /**\n   *\n   * @polymerBehavior PxMapBehavior.MarkerGroup\n   */\n  PxMapBehavior.MarkerGroupImpl = {\n    properties: {\n      /**\n       * A human-readable name for this layer group. If the map has a layer\n       * control panel, the user will click this name to show, hide, or\n       * manipulate this layer.\n       *\n       * @type {String}\n       */\n      name: {\n        type: String,\n        notify: true\n      },\n\n      /**\n       * An object formatted as a GeoJSON FeatureCollection with one or many Features.\n       * Each feature should be a point that will be represented as a marker.\n       * See the `px-map-marker-group` API documentation page for an in-depth\n       * guide that explains how to configure your features.\n       *\n       * The root feature collection object must have the following keys/values:\n       *\n       * - {String} `type`: Must be 'FeatureCollection'\n       * - {Array}  `features`: An array of feature objects\n       *\n       * Each feature object in the collection must have the following key/values:\n       *\n       * - {String} `type`: Must be 'Feature'\n       * - {Number} `id`: A unique numeric ID. If the feature is changed, it should keep its ID. No other features in the collection should have the same ID.\n       * - {Object} `geometry`\n       * - {String} `geometry.type`: Must be 'Point'\n       * - {Array}  `geometry.coordinates`: a pair of coordinates in `[lng,lat]` order\n       * - {Object} `properties`\n       * - {Object} `properties.marker-icon`: Settings to configure a marker icon\n       * - {Object} `properties.marker-popup`: [OPTIONAL] Settings to configure a marker icon\n       *\n       * @type {Object}\n       */\n      data: {\n        type: Object,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * Internal representation of the colorsByType object. See `_calculateColorsByType`.\n       * @type {Object}\n       */\n      _colorsByType: {\n        type: Object,\n        value: function() {\n          return {};\n        }\n      },\n\n      /**\n       * An object mapping categories of icons to their respective colors. Each\n       * key should be a string representing the name of an `icon-type` to\n       * a valid CSS color value (e.g. hex color, `rgb()` color). Set the\n       * `icon-type` as a sub-property of `properties.marker-icon` for each marker\n       * feature in the FeatureCollection you pass into the `data` attribute.\n       *\n       * By default, the available types are:\n       * - \"unknown\" : \"--px-map-icon-unknown-color\" (default: gray)\n       * - \"info\" : \"--px-map-icon-info-color\" (default: blue)\n       * - \"warning\" : \"--px-map-icon-warning-color\" (default: orange)\n       * - \"important\" : \"--px-map-icon-important-color\" (default: red)\n       * - \"custom-n\" : \"--px-map-color-custom-n\" (default: n/a)\n       *\n       * Example #1 - `colorsByType` object\n       *\n       * ```\n       * {\n       *   \"info\" : \"blue\",\n       *   \"warning\" : \"orange\",\n       *   \"important\" : \"red\",\n       *   \"unknown\" : \"gray\"\n       * }\n       * ```\n       *\n       * Example #2 - `colorsByType` object with custom types\n       *\n       * ```\n       * {\n       *   \"info\" : \"blue\",\n       *   \"custom-0\" : \"salmon\",\n       *   \"custom-1\" : \"lime\",\n       *   \"custom-2\" : \"crimson\"\n       * }\n       * ```\n       *\n       * @type {Object}\n       */\n      colorsByType: {\n        type: Object,\n        value: function(){\n          return {};\n        },\n        observer: '_calculateColorsByType'\n      },\n\n      /**\n       * Overrides the default icon creation function to allow drawing of custom\n       * cluster and marker icons. Note that if you replace these functions you\n       * should ensure your custom functions are very fast â€” these methods are\n       * called continuously as the user zooms through the map and clusters and\n       * markers are redrawn.\n       *\n       * Pass in an object with keys `cluster` or `marker` and values of functions.\n       * You can pass in one or both keys/values depending on which icon(s)\n       * you want to create.\n       *\n       * - The `cluster` function should accept one parameter, an `L.MarkerCluster` instance, and return a constructed `L.Icon` or `L.DivIcon` instance.\n       * - The `marker` function should accept one parameter, an Object with marker settings, and return a constructed `L.Marker` instance with an attached icon.\n       *\n       * @type {Object}\n       */\n      iconFns: {\n        type: Object,\n        value: function(){\n          return {\n            cluster: undefined,\n            marker: undefined\n          }\n        }\n      },\n\n      /**\n       * Allows advanced configurations of the cluster behaviors and styles. Note\n       * that the cluster comes pre-configured with settings that will work\n       * for most use cases; the `clusterConfig` allows those settings to be\n       * overriden but may cause unexpected behaviors when conflicting settings\n       * are used. Leave the default configuration (by not setting this attribute)\n       * if you're unsure of how to use it.\n       *\n       * The following settings are available:\n       *\n       * - {Boolean} `showCoverageOnHover`: [default=true] Shows the bounds of a cluster as a polygon when its icon is hovered\n       * - {Boolean} `zoomToBoundsOnClick`: [default=true] Zooms to bounds of a cluster when its icon is clicked\n       * - {Boolean} `spiderfyOnMaxZoom`: [default=true] Spiderfies the markers in a cluster when it is clicked at the max zoom level\n       * - {Boolean} `removeOutsideVisibleBounds`: [default=true] Removes cluster icons and markers when they are too far outside the visible map bounds\n       * - {Boolean} `animate`: [default=true] Animates cluster splitting, joining, zooming, and spiderfying\n       * - {Number} `disableClusteringAtZoom`: [default=undefined] If set, when the user zooms below this level markers will not be clustered (do not combine with `spiderfyOnMaxZoom`)\n       * - {Number} `maxClusterRadius`: [default=150] The maximum radius in pixels a cluster will cover from the central marker. Lower numbers make smaller clusters. Setting below the default may cause cluster icons to overlap.\n       * - {Object} `polygonOptions`: [default=150] Options passed to draw the cluster cover polygon\n       *   - {Boolean} `polygonOptions.stroke`: [default=true] If true the polygon will have a stroke line around the outside\n       *   - {String} `polygonOptions.color`: [default=--px-map-marker-group-cluster-polygon-stroke-color] Sets the stroke color, prefer setting with the style variable\n       *   - {String} `polygonOptions.fillColor`: [default=--px-map-marker-group-cluster-polygon-fill-color] Sets the fill color color, prefer setting with the style variable.\n       *   - {Number} `polygonOptions.fillOpacity`: [default=0.4] Sets the opacity of the polygon fill\n       * - {Object} `spiderLegPolylineOptions`: [default=undefined] Sets the style for the marker spiderfy legs, see [PolylineOptions](http://leafletjs.com/reference.html#polyline-options)\n       *\n       * @type {Object}\n       */\n      clusterConfig: {\n        type: Object\n      }\n    },\n\n    // PUBLIC METHODS\n\n    /**\n     * Forces the marker group to check the `data` attribute, look for differences\n     * in the data from the last draw, and make any necessary updates. Call this\n     * method if you are passing an object by reference to `data` and making\n     * deep updates that don't trigger changes.\n     */\n    update() {\n      if (!this.elementInst) return;\n\n      const {data} = this.getInstOptions();\n      const features = this._syncDataWithMarkers(data.features, this.elementInst);\n      this._notifyNewFeatures(features);\n    },\n\n    /**\n     * Skips the smart diffing system that only updates markers when their\n     * feature properties have changed. Forces a redraw of all markers\n     */\n    redraw() {\n      if (!this.elementInst) return;\n      this._clearAllMarkersAndData(this.elementInst);\n      this.update();\n    },\n\n    // INSTANCE METHODS\n\n    addInst(parent) {\n      // Bind custom events for this cluster. Events will be unbound automatically.\n      const spiderifyFn = this._handleClusterSpiderify.bind(this);\n      const unspiderifyFn = this._handleClusterUnspiderify.bind(this);\n      const markerTapFn = this._handleSingleMarkerTap.bind(this);\n      const markerDoubleClickFn = this._handleSingleMarkerDoubleClick.bind(this);\n      const clusterTapFn = this._handleClusterTap.bind(this);\n      this.bindEvents({\n        'spiderfied' : spiderifyFn,\n        'unspiderfied' : unspiderifyFn,\n        'click' : markerTapFn,\n        'dblclick' : markerDoubleClickFn,\n        'clusterclick' : clusterTapFn\n      });\n\n      PxMapBehavior.LayerImpl.addInst.call(this, parent);\n\n      this.async(function(){\n        this.fire('px-map-marker-group-added');\n      });\n    },\n    /**\n     * Fired when the marker group is attached to a parent layer (e.g. the map).\n     *\n     * Note that it isn't guaranteed that all marker clusters and individual\n     * markers added to the group have drawn, only that the marker group itself\n     * has attached to a parent. Marker clusters and individual may be drawn\n     * asynchronously, and data may be added or changed later to cause additional\n     * redraws.\n     *\n     * Listen to the `px-map-marker-group-features-changed` event for notifications\n     * on the features in the cluster.\n     *\n     * @event px-map-marker-group-added\n     */\n\n    removeInst(parent) {\n      PxMapBehavior.LayerImpl.removeInst.call(this, parent);\n    },\n\n    createInst(options={}) {\n      const cluster = L.markerClusterGroup(options);\n\n      if (options.data) {\n        const features = this._syncDataWithMarkers(options.data.features, cluster);\n        this._notifyNewFeatures(features);\n      }\n\n      return cluster;\n    },\n\n    updateInst(lastOptions, nextOptions) {\n      if (nextOptions.data) {\n        const features = this._syncDataWithMarkers(nextOptions.data.features, this.elementInst);\n        this._notifyNewFeatures(features);\n      }\n    },\n\n    getInstOptions() {\n      // Set the default cluster options\n      const defaultOptions = {\n        showCoverageOnHover: true,\n        maxClusterRadius: 150,\n        spiderifyOnMaxZoom: true,\n        removeOutsideVisibleBounds: true,\n        animate: true,\n        polygonOptions: {\n          stroke: true,\n          color: this.getComputedStyleValue('--internal-px-map-marker-group-cluster-polygon-stroke-color'),\n          fillColor: this.getComputedStyleValue('--internal-px-map-marker-group-cluster-polygon-fill-color'),\n          fillOpacity: 0.4\n        }\n      };\n      // Overwrite with any developer-provided cluster options in `clusterConfig`\n      const options = Object.assign(defaultOptions, (this.clusterConfig || {}));\n      // Assign the `data` and `iconCreateFunction` options. These cannot be\n      // configured through the `clusterConfig` attribture\n      options.data = this._getValidData();\n      options.iconCreateFunction = this._createClusterIcon.bind(this);\n      // Return the options composed together\n      return options;\n    },\n\n    /**\n     * Takes a `Set` of feature objects. Fires an event with the bounds of the\n     * feature set.\n     *\n     * @param {Set} featureSet\n     */\n    _notifyNewFeatures(featureSet) {\n      if (!featureSet || !(featureSet instanceof Set) || !featureSet.size) return;\n\n      this.async(function _notifyNewFeaturesDebounce() {\n        const bounds = L.latLngBounds();\n        let feature;\n        for (feature of featureSet) {\n          // Reminder: the coordinates array is backwards, switch from `lngLat` to `latLng`\n          bounds.extend([feature.geometry.coordinates[1], feature.geometry.coordinates[0]])\n        }\n        this.fire('px-map-marker-group-features-changed', { bounds: bounds });\n      }, 1);\n    },\n    /**\n     * Fired when the marker group's features are changed (i.e. when a GeoJSON\n     * FeatureCollection is set or updated through the group's `data` attribute).\n     * If any features are available, sends out the extend of their bounds.\n     *\n     *   * {Object} detail - Contains the event details\n     *   * {L.LatLngBounds} detail.bounds - Custom Leaflet bounds instance representing the total area covered by the features\n     *\n     * @event px-map-marker-group-features-changed\n     */\n\n    /**\n     * Determines if the data provided through the `data` attribute appears to\n     * be valid GeoJSON. This is a high-level check for the existence of\n     * necessary keys/values. It does not deeply validate each feature\n     * for correctness.\n     */\n    _getValidData() {\n      if (!this.data) {\n        // It's possible we will be initialized without any data. Don't complain\n        // loudly if there's no data, just return `undefined`.\n        return undefined;\n      }\n\n      const dataIsNotValid = (\n        (typeof this.data !== 'object') ||\n        (this.data.type !== 'FeatureCollection') ||\n        (!Array.isArray(this.data.features)) ||\n        !this.data.features.length ||\n        (typeof this.data.features[0] !== 'object')\n      );\n\n      if (dataIsNotValid) {\n        console.log(`PX-MAP CONFIGURATION ERROR:\n          The \\`data\\` attribute for ${this.is} is not valid GeoJSON. Valid GeoJSON\n          that follows the FeatureCollection standard is required to draw the\n          marker clusters. See the GeoJSON spec website (http://geojson.org/geojson-spec.html)\n          for more information on what is required.\n\n          The minimum requirements for ${this.is} are:\n          - Must be a valid JavaScript object (or deserializable to an object)\n          - Must have key \\`type\\` with value 'FeatureCollection'\n          - Must have key \\`features\\` with value of an array with length\n          - Each entry in \\`features\\` must be a valid object\n        `);\n\n        return undefined;\n      }\n\n      return this.data;\n    },\n\n    created: function() {\n      var updateFn = this.updateStyles;\n      this.updateStyles = this._handleStylesUpdated.bind(this);\n      this._updateStylesFn = updateFn;\n    },\n\n    /**\n     * Proxies the default `updateStyles` function provided by Polymer. When the\n     * `updateStyles` function is run we know the colors for markers may have\n     * been changed (e.g. by setting new CSS custom properties). We allow\n     * the update to happen then get the colors for the markers again. If\n     * any colors are changed from the last draw, we redraw the markers.\n     */\n    _handleStylesUpdated: function() {\n      this._updateStylesFn();\n      this._calculateColorsByType(this.colorsByType);\n    },\n\n    _createClusterIcon(cluster) {\n      // If the developer supplies a `iconFns.cluster` function, pass the options\n      // to that function and return the result.\n      if (this.iconFns.cluster) {\n        return this.iconFns.cluster.call(this, cluster);\n      }\n\n      // Otherwise, build the marker ourselves\n      const markers = cluster.getAllChildMarkers();\n      const count = markers.length;\n\n      // Count markers and group by type\n      const types = this._indexClusterMarkersByType(markers);\n\n      // Get the colors for each type\n      let colors = this._colorsByType;\n\n      // Get the container size for this count\n      const containerSize = this._getClusterIconSize(count);\n      // Get the path (chart stroke width) and border width for this chart\n      const pathSize = this._getStyleValueAsNum('--internal-px-map-marker-group-cluster-path-size') || 10;\n      const borderSize = this._getStyleValueAsNum('--internal-px-map-marker-group-cluster-border-size') || 0;\n\n      // Set up the options to send into ClusterIcon\n      const options = {\n        count: count,\n        countByType: types,\n        colorsByType: colors,\n        containerSize: containerSize,\n        pathSize: pathSize,\n        borderSize: borderSize,\n        styleScope: this.isShadyScoped() ? this.getShadyScope() : undefined,\n        markers: markers\n      };\n\n      return new PxMap.ClusterIcon(options);\n    },\n\n    /**\n     * Calculates the colors for the marker icons and clusters. The following\n     * things are read and applied:\n     *\n     * 1. `colorsByType` property/attribute set by the developer\n     * ...OVERRIDES...\n     * 2. CSS custom properties decoded into an object (from `_getAllIconColors`),\n     *    includes default colors\n     *\n     * If called again later when colors are updated, checks if the colors\n     * have changed and redraws all markers to pick up the changes.\n     *\n     * @param  {Object} publicColorsByType\n     */\n    _calculateColorsByType: function(publicColorsByType) {\n      var newColorsByType = Object.assign({}, this._getAllIconColors(), publicColorsByType || {});\n      var lastColorsByTypeStringified = JSON.stringify(this._colorsByType);\n      if (JSON.stringify(newColorsByType) !== lastColorsByTypeStringified) {\n        this._colorsByType = newColorsByType;\n        if (lastColorsByTypeStringified !== '{}') {\n          // If the last colorsByType was not empty, this isn't the first time\n          // we set the colors. We should redraw to force all the clusters\n          // to pick up their new colors. We want to guard against doing\n          // this the first time colorsByType is set so we don't waste a bunch\n          // of time drawing the markers then throw it away and redraw them.\n          this.redraw();\n        }\n      }\n    },\n\n    /**\n     * Creates and returns a `colors` object from CSS custom properties. If the\n     * developer does not set any of the CSS properties, a default color will\n     * be used for the four standard icon types.\n     *\n     * @return {Object}\n     */\n    _getAllIconColors: function() {\n      var colors = {};\n      colors.info = this.getComputedStyleValue('--internal-px-map-icon-info-color');\n      colors.warning = this.getComputedStyleValue('--internal-px-map-icon-warning-color');\n      colors.important = this.getComputedStyleValue('--internal-px-map-icon-important-color');\n      colors.unknown = this.getComputedStyleValue('--internal-px-map-icon-unknown-color');\n      let customColor;\n      for (let i=0; i<101; i++) {\n        customColor = this.getComputedStyleValue(`--px-map-color-custom-${i}`);\n        if (!customColor || customColor === \"\") {\n          break;\n        }\n        colors[`custom-${i}`] = customColor;\n      }\n      return colors;\n    },\n\n    _getStyleValueAsNum(styleValName) {\n      // Try to get from the \"cache\"\n      this.__styleVals = (this.__styleVals || {});\n      if (this.__styleVals[styleValName]) return this.__styleVals[styleValName];\n\n      const computedVal = this.getComputedStyleValue(styleValName);\n\n      if (computedVal && computedVal.indexOf('px') !== -1) {\n        const valWithoutSuffix = computedVal.replace('px','');\n        const valAsNum = Math.floor(valWithoutSuffix);\n        this.__styleVals[styleValName] = valAsNum;\n        return valAsNum;\n      } else {\n        return undefined;\n      }\n    },\n\n    _getClusterIconSize(count) {\n      // for count 1-9, size is small\n      if (count < 10) {\n        return 60;\n      }\n      // for count 10-39, size is medium\n      if ((count >= 10) && (count < 40)) {\n        return 75;\n      }\n      // for count 40+, size is large\n      if (count > 40) {\n        return 90;\n      }\n    },\n\n    /**\n     * Takes a group of marker instances and returns an object with keys of the\n     * marker types in the group and values with the number of markers in\n     * each group.\n     *\n     * @param {Array} markers - Array of marker instances\n     * @return {Object}\n     */\n    _indexClusterMarkersByType(markers) {\n      return markers.reduce((types, marker) => {\n        if (marker.featureProperties && marker.featureProperties['marker-icon'] && marker.featureProperties['marker-icon']['icon-type']) {\n          types[marker.featureProperties['marker-icon']['icon-type']] = (types[marker.featureProperties['marker-icon']['icon-type']] || 0) + 1;\n        }\n        return types;\n      }, {});\n    },\n\n    /**\n     * Clears all markers and clusters from the marker group. Clears out the\n     * cached `_features` and `_markers` values so that `_syncDataWithMarkers`\n     * will treat all data as new and redraw it the next time it is called.\n     */\n    _clearAllMarkersAndData: function(clusterInst) {\n      clusterInst.clearLayers();\n      this._features = null;\n      this._markers = null;\n    },\n\n    /**\n     * Takes an array of GeoJSON feature objects and an `L.MarkerClusterGroup`\n     * instance. Diffs the feature array against any previous feature arrays\n     * passed to this method and updates the cluster instance. Returns a\n     * `Set` of features.\n     *\n     * @param {Array} newFeatures\n     * @param {L.MarkerClusterGroup} clusterInst\n     * @return {Set} features\n     */\n    _syncDataWithMarkers(newFeatures, clusterInst) {\n      if (!newFeatures.length) return;\n\n      const featuresSet = this._features = (this._features || new Set());\n      const markersMap = this._markers = (this._markers || new WeakMap());\n\n      const {featuresToAdd, featuresToUpdate, featuresToRemove, nextFeaturesSet, nextMarkersMap} = this._diffNewFeatures(newFeatures, featuresSet, markersMap);\n\n      let feature, cachedMarker, markersToOperate;\n\n      if (featuresToAdd.size) {\n        markersToOperate = [];\n        for (feature of featuresToAdd) {\n          cachedMarker = nextMarkersMap.get(feature);\n          cachedMarker.marker = this._createMarker(feature);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.set(feature, cachedMarker);\n        }\n        clusterInst.addLayers(markersToOperate);\n        markersToOperate = null;\n      }\n\n      if (featuresToUpdate.size) {\n        markersToOperate = [];\n        for (feature of featuresToUpdate) {\n          cachedMarker = nextMarkersMap.get(feature);\n          cachedMarker.marker = this._updateMarker(feature, cachedMarker.marker);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.set(feature, cachedMarker);\n        }\n        clusterInst.refreshClusters(markersToOperate);\n        markersToOperate = null;\n      }\n\n      if (featuresToRemove.size) {\n        markersToOperate = [];\n        for (feature of featuresToRemove) {\n          cachedMarker = nextMarkersMap.get(feature);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.delete(feature);\n        }\n        clusterInst.removeLayers(markersToOperate);\n        markersToOperate = null;\n      }\n\n      this._features = nextFeaturesSet;\n      this._markers = nextMarkersMap;\n      featuresSet.clear()\n\n      featuresToAdd.clear();\n      featuresToUpdate.clear();\n      featuresToRemove.clear();\n\n      return this._features;\n    },\n\n    _diffNewFeatures(newFeatures, lastFeatureSet, markerMap) {\n      // Keep track of our new feature set, which will replace `featureSet`\n      const nextFeaturesSet = new Set();\n\n      // Keep track of markers to add\n      const featuresToAdd = new Set();\n      const featuresToUpdate = new Set();\n\n      // Placeholders for our loop\n      let i, len, valid, known, cachedMarker, featureHash;\n\n      // Loop over features to add unknown features to the cluster or update known features if necessary\n      for (i=0, len=newFeatures.length; i<len; i++) {\n        // If these tests aren't met, the feature is invalid and can't be drawn as a marker\n        // Any invalid markers won't be visited and will be removed\n        valid = ((newFeatures[i].id) && (newFeatures[i].geometry && newFeatures[i].geometry.type === 'Point') && (newFeatures[i].geometry.coordinates instanceof Array && newFeatures[i].geometry.coordinates.length === 2));\n        if (!valid) continue;\n\n        // Determine if this feature is already represented in the cluster\n        known = lastFeatureSet.has(newFeatures[i]);\n\n        // This is a valid feature we don't know, create a marker for this feature and add it.\n        if (!known) {\n          // Mark this as a marker to add\n          featuresToAdd.add(newFeatures[i]);\n          // Remove from last feature set and add to next feature set\n          lastFeatureSet.delete(newFeatures[i]);\n          nextFeaturesSet.add(newFeatures[i]);\n          // Build a new cached marker object with a hash of the feature\n          cachedMarker = { marker: null, hash: JSON.stringify(newFeatures[i]) };\n          markerMap.set(newFeatures[i], cachedMarker);\n          // Skip to next loop iteration\n          continue;\n        }\n\n        // We know this feature and have a marker for it. Ensure the marker is up-to-date.\n        if (known) {\n          cachedMarker = markerMap.get(newFeatures[i]);\n          featureHash = JSON.stringify(newFeatures[i]);\n          // If there's a difference, mark this marker as one to update\n          if (cachedMarker.hash !== featureHash) {\n            featuresToUpdate.add(newFeatures[i]);\n            // Update the cached marker object with the new hash of the feature\n            cachedMarker.hash = featureHash;\n            markerMap.set(newFeatures[i], cachedMarker);\n          }\n          // Remove from last feature set and add to next feature set\n          lastFeatureSet.delete(newFeatures[i]);\n          nextFeaturesSet.add(newFeatures[i]);\n        }\n      }\n\n      // Any markers remaining in the last feature set need to be remove\n      const featuresToRemove = lastFeatureSet.size ? lastFeatureSet : new Set();\n\n      // Clear all references in the last feature set to ensure values can\n      // be garbage collected\n      lastFeatureSet = null;\n\n      return {\n        featuresToAdd: featuresToAdd,\n        featuresToUpdate: featuresToUpdate,\n        featuresToRemove: featuresToRemove,\n        nextFeaturesSet: nextFeaturesSet,\n        nextMarkersMap: markerMap\n      };\n    },\n\n    _createMarker(feature) {\n      // Extract geometry (GeoJSON coordinate pairs are Lat/Lng, we need Lng/Lat,\n      // so we have to reverse)\n      const [lat, lng] = feature.geometry.coordinates;\n      // Create a marker\n      const marker = L.marker([lng, lat]);\n\n      // If any icon settings were passed with the feature, fetch them to pass\n      // to the icon constructor\n      const iconSettings = (feature.properties['marker-icon']) ? this._extractMarkerIconSettings(feature.properties['marker-icon']) : {};\n      iconSettings.base = iconSettings.base || 'static-icon';\n      iconSettings.type = iconSettings.type || 'info';\n\n      iconSettings.color = this._colorsByType[iconSettings.type] || 'black';\n      iconSettings.featureProperties = feature.properties;\n      const icon = this._createMarkerIcon(iconSettings);\n      marker.setIcon(icon);\n\n      // Attach the properties to the marker instance to read later\n      marker.featureProperties = feature.properties;\n\n      return marker;\n    },\n\n    _updateMarker(feature, marker) {\n      const {lat, lng} = marker.getLatLng();\n      const [nextLng, nextLat] = feature.geometry.coordinates;\n\n      if (lat !== Number(nextLat) || lng !== Number(nextLng)) {\n        marker.setLatLng([nextLat, nextLng]);\n      }\n\n      const iconSettings = (feature.properties['marker-icon']) ? this._extractMarkerIconSettings(feature.properties['marker-icon']) : {};\n      iconSettings.base = iconSettings.base || 'static-icon';\n      iconSettings.type = iconSettings.type || 'info';\n      iconSettings.featureProperties = feature.properties;\n      const icon = this._createMarkerIcon(iconSettings);\n      marker.setIcon(icon);\n\n      // Attach the properties to the marker instance to read later\n      marker.featureProperties = feature.properties;\n\n      return marker;\n    },\n\n    _extractMarkerIconSettings(featSettings) {\n      const featSettingsKeys = Object.keys(featSettings);\n      if (!featSettingsKeys.length) return undefined;\n\n      const iconSettings = {};\n      let i, len, featKeyCamelized;\n\n      for (i=0, len=featSettingsKeys.length; i<len; i++) {\n        if (featSettingsKeys[i].substring(0,5) !== \"icon-\") continue;\n        featKeyCamelized = featSettingsKeys[i].substring(5).replace(/(\\-[a-z])/g, (match) => match.charAt(1).toUpperCase());\n        iconSettings[featKeyCamelized] = featSettings[featSettingsKeys[i]];\n      }\n\n      return iconSettings;\n    },\n\n    _createMarkerIcon(options) {\n      // If the developer supplies a `iconFns.marker` function, pass the options\n      // to that function and return the result.\n      if (this.iconFns.marker) {\n        return this.iconFns.marker.call(this, options);\n      }\n      // If we are in Shady DOM with a style scope, apply it\n      options.styleScope = this.isShadyScoped() ? this.getShadyScope() : undefined;\n      // Otherwise, attempt to convert the feature's 'icon-base' to a klass name\n      // and call the constructor for that klass\n      const klassName = this._strToKlassName(options.base);\n\n      return new PxMap[klassName](options);\n    },\n\n    _strToKlassName(str) {\n      return str.charAt(0).toUpperCase() + str.substring(1).replace(/(\\-[a-z])/g, (match) => match.charAt(1).toUpperCase());\n    },\n\n    /**\n     * When the cluster is spiderified, set its visibility to hidden to ensure\n     * it is not kept around as an opaque background to the markers.\n     */\n    _handleClusterSpiderify(evt) {\n      if (!evt || !evt.cluster || !evt.cluster._icon) return;\n      evt.cluster._icon.style.visibility = 'hidden';\n    },\n\n    /**\n     * When the cluster is unspiderified, set its visibility to visible to ensure\n     * it is shown again on the map.\n     */\n    _handleClusterUnspiderify(evt) {\n      if (!evt || !evt.cluster || !evt.cluster._icon) return;\n      evt.cluster._icon.style.visibility = 'visible';\n    },\n\n    /**\n     * When an individual marker (not a marker cluster) is clicked, if that\n     * marker has a popup attribute, bind a show a popup.\n     */\n    _handleSingleMarkerTap(evt) {\n      if (evt.layer && evt.layer.getLatLng() instanceof L.LatLng) {\n        const latLng = L.latLng(evt.layer.getLatLng());\n        const {lat, lng} = latLng;\n        const detail = {\n          latLng: latLng,\n          lat: lat,\n          lng: lng,\n          feature: evt.layer.featureProperties ? evt.layer.featureProperties : undefined\n        };\n        this.fire('px-map-marker-group-marker-tapped', detail);\n      }\n\n      if (evt.layer && evt.layer.featureProperties && evt.layer.featureProperties.hasOwnProperty('marker-popup')) {\n        this._bindAndOpenPopup(evt.layer);\n      }\n    },\n    /**\n     * Fired when an individual marker (not a cluster) is tapped by the user.\n     *\n     *   * {Object} detail - Contains the event details\n     *   * {Number} detail.lat - Latitude of the marker\n     *   * {Number} detail.lng - Longitude of the marker\n     *   * {L.LatLng} detail.latLng - Custom Leaflet object containing the lat and lng\n     *   * {Object|undefined} detail.feature - Object containing the marker's GeoJSON source\n     *\n     * @event px-map-marker-group-marker-tapped\n     */\n\n    _handleSingleMarkerDoubleClick(evt) {\n      const latLng = L.latLng(evt.layer.getLatLng());\n      const {lat, lng} = latLng;\n      const detail = {\n        latLng: latLng,\n        lat: lat,\n        lng: lng,\n        feature: evt.layer.featureProperties ? evt.layer.featureProperties : undefined\n      };\n      this.fire('px-map-marker-group-marker-double-clicked', detail);\n    },\n    /**\n     * Fired when an individual marker (not a cluster) is double clicked by the user.\n     * Note that this will only work on non-touch (e.g. desktop) devices. Touch (e.g. mobile) devices cannot respond to double click/tap events.\n     *\n     *   * {Object} detail - Contains the event details\n     *   * {Number} detail.lat - Latitude of the marker\n     *   * {Number} detail.lng - Longitude of the marker\n     *   * {L.LatLng} detail.latLng - Custom Leaflet object containing the lat and lng\n     *   * {Object|undefined} detail.feature - Object containing the marker's GeoJSON source\n     *\n     * @event px-map-marker-group-marker-double-clicked\n     */\n\n    _handleClusterTap(evt) {\n      const latLngBounds = evt.layer.getBounds();\n      const markers = evt.layer.getAllChildMarkers();\n      const features = [];\n      for (let i=0; i<markers.length; i++) {\n        features.push(markers[i].featureProperties);\n      }\n      const detail = {\n        bounds: latLngBounds,\n        features: features\n      };\n      this.fire('px-map-marker-group-cluster-tapped', detail);\n    },\n    /**\n     * Fired when a cluster icon (not an individual marker) is tapped by the user.\n     *\n     *   * {Object} detail - Contains the event details\n     *   * {L.LatLngBounds} detail.bounds - Custom Leaflet bounds instance representing the total area covered by the features in this cluster\n     *   * {Array} detail.features - Array of features that are drawn as markers in this cluster\n     *\n     * @event px-map-marker-group-cluster-tapped\n     */\n\n    _bindAndOpenPopup(marker) {\n      if (!marker || !marker.bindPopup || !marker.openPopup) return;\n\n      const popupSettings = this._featSettingsToProps(marker.featureProperties['marker-popup'], 'popup');\n      if (!popupSettings || !Object.keys(popupSettings).length) return;\n\n      const klassName = (popupSettings._Base && PxMap.hasOwnProperty(popupSettings._Base)) ? popupSettings._Base : 'InfoPopup';\n      const popup = new PxMap[klassName](popupSettings);\n\n      marker.bindPopup(popup).openPopup();\n      marker.__boundCloseFn = this._unbindAndClosePopup.bind(this, marker);\n      marker.on('popupclose', marker.__boundCloseFn);\n    },\n\n    _unbindAndClosePopup(marker) {\n      if (!marker || !marker.getPopup || !marker.getPopup()) return;\n\n      marker.off('popupclose', marker.__boundCloseFn);\n      marker.__boundCloseFn = null;\n      marker.closePopup().unbindPopup();\n    },\n\n    /**\n     * Takes an object harvested from a GeoJSON feature `properties` block and\n     * converts it into properties that can be passed to a constructor.\n     *\n     * For example, takes an object like this:\n     *\n     * ```\n     * {\n     *   \"popup-base\" : \"data-popup\",\n     *   \"popup-title\" : \"Some title\",\n     *   \"popup-data\" : { ... }\n     * }\n     * ```\n     *\n     * and returns an object like this:\n     *\n     * ```\n     * {\n     *   \"_Base\" : \"DataPopup\",\n     *   \"title\" : \"Some title\",\n     *   \"data\" : { ... }\n     * }\n     * ```\n     *\n     * Optionally, pass a prefix as a string to extract the correct properties.\n     * E.g. to extract \"popup-title\" to \"title\", pass the prefix \"popup\".\n     * If you pass no prefix param, everything that matches the dash case\n     * search `/[a-z]+\\-(.*)/` will be returned\n     *\n     * Keys that match the pattern `*-base` will be converted from dash case to\n     * class case (e.g. 'data-popup' to 'PopupData') and returned with the `_Base`\n     * key to help call a constructor by reference.\n     *\n     * @param {Object} settings\n     * @param {String} [prefix]\n     * @return {Object}\n     */\n    _featSettingsToProps(settings, prefix) {\n      const keys = Object.keys(settings);\n      if (!keys.length) return undefined;\n\n      const settingsAsProps = {};\n      let i=0, len=keys.length, newKey;\n\n      for (; i<len; i++) {\n        // Check if it has the prefix\n        if (prefix && keys[i].substr(0, prefix.length) !== prefix) {\n          continue;\n        }\n        // If it's the base, classify it and set it as the `_Base` key\n        if (/^[A-Za-z]+\\-base$/.test(keys[i])) {\n          settingsAsProps['_Base'] = this._strToKlassName(settings[keys[i]]);\n          continue;\n        }\n        newKey = keys[i].replace(/^[A-Za-z]+\\-(.*)$/, \"$1\");\n        settingsAsProps[newKey] = settings[keys[i]];\n      }\n\n      return settingsAsProps;\n    },\n  };\n  /* Bind MarkerGroup behavior */\n  /** @polymerBehavior */\n  PxMapBehavior.MarkerGroup = [\n    PxMapBehavior.Layer,\n    PxMapBehavior.MarkerGroupImpl\n  ];\n})();\n"]}