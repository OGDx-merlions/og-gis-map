{"version":3,"sources":["px-map-behavior-root.es6.js"],"names":["window","PxMapBehavior","TrackMarkersImpl","properties","fitToMarkers","type","Boolean","value","observer","fitToMarkersPadding","Number","fitToMarkersZoom","String","addInst","parent","listen","_knownMarkers","Map","LeafletRootImpl","call","removeInst","unlisten","clear","_handleMarkerAdded","evt","localEvt","Polymer","dom","rootTarget","elementInst","event","detail","latLng","set","_fitMapToMarkersIfSet","_handleMarkerRemoved","knownMarker","has","delete","_handleMarkerGroupUpdated","bounds","_handleMarkerGroupRemoved","_fitMapToMarkers","debounce","size","_markersToBoundsWithPadding","isValid","getCenter","zoom","_getZoomLevelForFit","setView","markersMap","padding","L","latLngBounds","forEach","LatLng","LatLngBounds","extend","pad","fitSetting","map","getMinZoom","getBoundsZoom","fitMapToMarkers","crs","Object","lat","notify","lng","maxZoom","minZoom","maxBounds","Array","disableDragging","disableScrollZoom","disableTouchZoom","disableDoubleClickZoom","disableAttribution","attributionPrefix","flexToSize","reflectToAttribute","attached","Element","_afterFirstRender","RenderStatus","afterNextRender","canAddInst","fire","detached","shouldRemoveInst","shouldAddInst","ElementImpl","_canBeNum","latLngIsValid","createInst","options","mapEl","root","querySelector","mapInst","attributionControl","setPrefix","isShadyScoped","__addShadyScope","scopeSubtree","bind","$","mapMoveFn","_handleMapMove","zoomStartFn","_handleZoomStart","zoomEndFn","_handleZoomEnd","bindEvents","getInstOptions","zoomControl","CRS","EPSG3857","center","undefined","dragging","scrollWheelZoom","touchZoom","doubleClickZoom","updateInst","lastOptions","nextOptions","_updateMapView","isNaN","setMaxZoom","setMinZoom","setMaxBounds","enable","disable","invalidateSize","getZoom","val","hideError","console","log","is","__isZooming","__onZoomEnd","getBounds","getVisibleMarkers","mapBounds","markers","eachLayer","layer","isMarker","getLatLng","contains","indexOf","push","_markerCluster","marker","parentCluster","getVisibleParent","LeafletRoot","ParentLayer"],"mappings":"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","file":"px-map-behavior-root.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2018, General Electric\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function() {\n  'use strict';\n\n  /****************************************************************************\n   * BEHAVIORS\n   ****************************************************************************/\n\n  /* Ensures the behavior namespace is created */\n  window.PxMapBehavior = (window.PxMapBehavior || {});\n\n  /**\n   *\n   * @polymerBehavior PxMapBehavior.TrackMarkers\n   */\n  PxMapBehavior.TrackMarkersImpl = {\n    properties: {\n      /**\n       * Updates the visible bounds of the map to fit all markers as they are\n       * added. Markers are continuously monitored for changes, and any new\n       * markers added late in the map's lifecycle (e.g. markers created\n       * dynamically long after the map is loaded) will trigger an additional\n       * resize of the map if they are not within its current visible bounds.\n       *\n       * This attribute is dynamic. To stop map resizes after some amount of time,\n       * disable this attribute.\n       *\n       *\n       * @type {Object}\n       */\n      fitToMarkers: {\n        type: Boolean,\n        value: false,\n        observer: '_fitMapToMarkersIfSet'\n      },\n\n      /**\n       * Optional setting that only works if `fitToMarkers` is enabled. Adds a\n       * padding between the edges of the map and the visible markers shown.\n       * Set to a percentage value (e.g. `0.25` for 25%). Defaults to 15%, setting\n       * to a lower value will lead to some large markers potentially not fitting\n       * on the map.\n       *\n       * @type {Number}\n       */\n      fitToMarkersPadding: {\n        type: Number,\n        value: 0.15\n      },\n\n      /**\n       * Optional setting that only works if `fitToMarkers` is enabled. Determines\n       * how the map will calculate its zoom level when fitting markers.\n       * Choose from the following options (default is 'max'):\n       *\n       *    * 'max' - the map will zoom to the lowest level that fits all markers (but not past the map's `maxZoom`)\n       *    * 'min' - the map will zoom to the highest level that fits all markers (but not past the map's `minZoom`)\n       *\n       * @type {String}\n       */\n      fitToMarkersZoom: {\n        type: String,\n        value: 'max'\n      }\n    },\n\n    addInst(parent) {\n      this.listen(this, 'px-map-marker-added', '_handleMarkerAdded');\n      this.listen(this, 'px-map-marker-group-features-changed', '_handleMarkerGroupUpdated');\n\n      this._knownMarkers = (this._knownMarkers || new Map());\n\n      PxMapBehavior.LeafletRootImpl.addInst.call(this);\n    },\n\n    removeInst(parent) {\n      this.unlisten(this, 'px-map-marker-added', '_handleMarkerAdded');\n      this.unlisten(this, 'px-map-marker-group-features-changed', '_handleMarkerGroupUpdated');\n\n      if (this._knownMarkers && this._knownMarkers instanceof Map) {\n        this._knownMarkers.clear();\n      }\n      this._knownMarkers = null;\n\n      PxMapBehavior.LeafletRootImpl.removeInst.call(this);\n    },\n\n    /**\n     * When an individual marker is added, record its location in the known markers\n     * map and ask the map to fit it later.\n     *\n     * Bind listeners on remove to keep the known markers map updated.\n     */\n    _handleMarkerAdded(evt) {\n      if (!this._knownMarkers) return;\n\n      const localEvt = Polymer.dom(evt);\n\n      if (localEvt.rootTarget && localEvt.rootTarget.elementInst && localEvt.event.detail.latLng) {\n        this._knownMarkers.set(localEvt.rootTarget.elementInst, localEvt.event.detail.latLng);\n        this.listen(localEvt.rootTarget, 'px-map-marker-removed', '_handleMarkerRemoved');\n        this._fitMapToMarkersIfSet();\n      }\n    },\n\n    /**\n     * When an individual marker is removed, delete it from the known markers\n     * map and stop. Don't ask the map to refit its bounds.\n     *\n     * Unbind listeners so the element can be cleaned up.\n     */\n    _handleMarkerRemoved(evt) {\n      if (!this._knownMarkers) return;\n\n      const localEvt = Polymer.dom(evt);\n      const knownMarker = this._knownMarkers.has(localEvt.rootTarget.elementInst || null);\n\n      if (knownMarker) {\n        this.unlisten(localEvt.rootTarget, 'px-map-marker-removed', '_handleMarkerRemoved');\n        this._knownMarkers.delete(localEvt.rootTarget.elementInst);\n      }\n    },\n\n    /**\n     * When marker groups are updated, set their new bounds in the known markers\n     * map. We don't need to worry about whether we've seen them before.\n     *\n     * Bind listeners on remove to keep the known markers map updated.\n     */\n    _handleMarkerGroupUpdated(evt) {\n      if (!this._knownMarkers) return;\n\n      const localEvt = Polymer.dom(evt);\n      const knownMarker = this._knownMarkers.has(localEvt.rootTarget.elementInst || null);\n\n      if (localEvt.rootTarget && localEvt.rootTarget.elementInst) {\n        if (!knownMarker) {\n          this.listen(localEvt.rootTarget, 'px-map-marker-group-removed', '_handleMarkerGroupRemoved');\n        }\n\n        this._knownMarkers.set(localEvt.rootTarget.elementInst, localEvt.event.detail.bounds);\n        this._fitMapToMarkersIfSet();\n      }\n    },\n\n    /**\n     * When marker groups are removed, delete their bounds from the known markers\n     * map and stop. Don't ask the map to refit its bounds.\n     *\n     * Unbind listeners so the element can be cleaned up.\n     */\n    _handleMarkerGroupRemoved(evt) {\n      if (!this._knownMarkers) return;\n\n      const localEvt = Polymer.dom(evt);\n      const knownMarker = this._knownMarkers.has(localEvt.rootTarget.elementInst || null);\n\n      if (knownMarker) {\n        this.unlisten(localEvt.rootTarget, 'px-map-marker-group-removed', '_handleMarkerGroupRemoved');\n        this._knownMarkers.delete(localEvt.rootTarget.elementInst);\n      }\n    },\n\n    /**\n     * Debounced function that iterates over the known markers map and fits the\n     * visible bounds of the map.\n     */\n    _fitMapToMarkers() {\n      this.debounce('fit-map-to-bounds', function() {\n        if (!this._knownMarkers || !this._knownMarkers.size) return;\n\n        const bounds = this._markersToBoundsWithPadding(this._knownMarkers, this.fitToMarkersPadding);\n\n        if (bounds && bounds.isValid()) {\n          let latLng = bounds.getCenter();\n          let zoom = this._getZoomLevelForFit(bounds, this.fitToMarkersZoom, this.elementInst);\n          this.elementInst.setView(latLng, zoom);\n        }\n      }, 10);\n    },\n\n    /**\n     * Takes a Map of known markers with values representing the marker's geometry\n     * as a `L.LatLng` or `L.LatLngBounds` instance and creates a bounds object\n     * that encompasses all the markers. Optionally pads the bounds by a percentage\n     * with the `padding` param.\n     *\n     * @param {Map} markersMap\n     * @param {Number} [padding]\n     * @return {L.LatLngBounds}\n     */\n    _markersToBoundsWithPadding(markersMap, padding) {\n      if (!markersMap || !markersMap.size) return;\n\n      let bounds = L.latLngBounds();\n      markersMap.forEach(value => {\n        if (value instanceof L.LatLng || value instanceof L.LatLngBounds) {\n          bounds.extend(value);\n        }\n      });\n\n      if (bounds.isValid() && (typeof padding === 'number')) {\n        bounds = bounds.pad(padding);\n      }\n\n      return bounds;\n    },\n\n    /**\n     * Takes a bounds, fit setting, zoom level, and map instance, and returns a\n     * new zoom level for the map.\n     *\n     * @param {L.LatLngBounds} bounds\n     * @param {String} fitSetting - see `fitToMarkersZoom` property for more details\n     * @param {L.Map} map\n     * @return {Number}\n     */\n    _getZoomLevelForFit(bounds, fitSetting, map) {\n      if (fitSetting === 'min') {\n        let zoom = map.getMinZoom() || 0;\n        return zoom;\n      }\n      if (fitSetting === 'max') {\n        let zoom = map.getBoundsZoom(bounds, true) - 1;\n        return zoom;\n      }\n    },\n\n    /**\n     * Called when the `fitToMarkers` attribute is updated. If it is set to true\n     * and a map is set, call the internal `_fitMapToMarkers` method.\n     */\n    _fitMapToMarkersIfSet() {\n      if (!this.elementInst || !this.fitToMarkers) return;\n      this._fitMapToMarkers();\n    },\n\n    /**\n     * Sets the map's visible bounds (latitude, longitude, and zoom) to fit all\n     * attached markers in a single view.\n     *\n     * Enable the `fit-to-markers` attribute to automatically fit all markers as\n     * they are added to the map.\n     *\n     * @return {Boolean} `true` if there were markers to fit, `false` if there were no markers to fit\n     */\n    fitMapToMarkers() {\n      if (!this.elementInst || !this._knownMarkers || !this._knownMarkers.size) {\n        return false;\n      }\n\n      this._fitMapToMarkers();\n      return true;\n    }\n  };\n\n  /**\n   *\n   * @polymerBehavior PxMapBehavior.LeafletRoot\n   */\n  PxMapBehavior.LeafletRootImpl = {\n    properties: {\n      /**\n       * The coordinate reference system to use when projecting geographic points\n       * into pixel coordinates. Can only be set once before the map is first\n       * initialized. If you don't know what this is, do not set it and the map\n       * will default to the most common web mapping projection (EPSG3857).\n       *\n       * @type {L.CRS}\n       */\n      crs: {\n        type: Object\n      },\n\n      /**\n       * The latitude of the active map center. Can be used to set or update\n       * the center of the map, or read from after the user moves the map to\n       * get updated coordinates.\n       *\n       * @type {Number}\n       */\n      lat: {\n        type: Number,\n        value: 37.7672375,\n        notify: true,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * The longitude of the active map center. Can be used to set or update\n       * the center of the map, or read from after the user moves the map to\n       * get updated coordinates.\n       *\n       * @type {Number}\n       */\n      lng: {\n        type: Number,\n        value: -121.9584131,\n        notify: true,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * The zoom level of the active map. Can be used to set or update\n       * the zoom level of the map, or read from after the user changes the\n       * map zoom level to an updated value.\n       *\n       * @type {Number}\n       */\n      zoom: {\n        type: Number,\n        value: 10,\n        notify: true,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * The maximum zoom level for the active map (the furthest the user can\n       * zoom in). Setting it at the map level will take precedence over the\n       * max zoom of all other layers, including tile layers. If you need to\n       * set different zoom bounds based on the visible tile layer, set the\n       * max zoom directly on your tile layer.\n       *\n       * @type {Number}\n       */\n      maxZoom: {\n        type: Number,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n      * The minimum zoom level for the active map (the furthest the user can\n      * zoom out). Setting it at the map level will take precedence over the\n      * min zoom of all other layers, including tile layers. If you need to\n      * set different zoom bounds based on the visible tile layer, set the\n      * min zoom directly on your tile layer.\n       *\n       * @type {Number}\n       */\n      minZoom: {\n        type: Number,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * Restricts the user from moving the map outside of a specific geographic\n       * boundary. The user will be bounced back if they attempt to pan outside the view.\n       * Disabled by default, letting the user pan to any point on the map.\n       *\n       * Pass an array of [lat,lng] values like the following:\n       *\n       *        [[40.712, -74.227], [40.774, -74.125]]\n       *\n       * The first pair should represent the southwest extend of the boundary,\n       * and the second  pair should represent the northeast extend of the\n       * boundary.\n       *\n       * @type {Array}\n       */\n      maxBounds: {\n        type: Array,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * Set to disable dragging of the map with the mouse or by touch. Use to\n       * restrict changing the map's visible area (e.g. for a static map) or\n       * to set up a map for being updated programmatically (e.g. through regular\n       * responses from an API).\n       *\n       * @type {Boolean}\n       */\n      disableDragging: {\n        type: Boolean,\n        value: false,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * Set to disable zooming with the scroll wheel. Useful if you have a map\n       * that takes up the full width of a page and want to allow the user to\n       * scroll/swipe past without getting stuck in a zoom-in-zoom-out loop.\n       *\n       * @type {Boolean}\n       */\n      disableScrollZoom: {\n        type: Boolean,\n        value: false,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * Set to disable the two-finger zoom gesture on touch devices.\n       *\n       * @type {Boolean}\n       */\n      disableTouchZoom: {\n        type: Boolean,\n        value: false,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * Set to disable zooming on double-click.\n       *\n       * @type {Boolean}\n       */\n      disableDoubleClickZoom: {\n        type: Boolean,\n        value: false,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * Set to disable the attribution control, which can be used to show the\n       * source of tile layers or other data overlays.\n       *\n       * This property is not dynamic and can only be set once when the map is\n       * first initialized.\n       *\n       * @type {Boolean}\n       */\n      disableAttribution: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Stringified HTML that will be used as the first item in your attribution\n       * list. Pass an <a> tag with a link to more information about your\n       * attribution source. Example: '<a href=\"https://example.com\">Example</a>'\n       *\n       * Defaults to a link to the Leaflet.js library. If an empty string is\n       * passed (\"\") the prefix will be hidden.\n       *\n       * @type {String}\n       */\n      attributionPrefix: {\n        type: String,\n        value: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>',\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * Uses flexbox to set the size of the map. Set the parent container\n       * to use `display: flex;` in your CSS and the map will automatically\n       * fill the container's available height and width.\n       *\n       * @type {Boolean}\n       */\n      flexToSize: {\n        type: Boolean,\n        reflectToAttribute: true,\n        value: false\n      }\n    },\n\n    attached() {\n      this.listen(this, 'px-map-element-ready-to-add', 'shouldAddInst');\n\n      if (Polymer.Element) {\n        this._afterFirstRender = false;\n        Polymer.RenderStatus.afterNextRender(this, () => {\n          this._afterFirstRender = true;\n          if (this.canAddInst()) {\n            this.fire('px-map-element-ready-to-add');\n          }\n        });\n      }\n      else {\n        this._afterFirstRender = true;\n      }\n\n      if (this.canAddInst()) {\n        this.fire('px-map-element-ready-to-add');\n      }\n    },\n\n    detached() {\n      this.unlisten(this, 'px-map-element-ready-to-add', 'shouldAddInst');\n      this.shouldRemoveInst();\n      this.removeInst();\n    },\n\n    shouldAddInst(evt) {\n      if (Polymer.dom(evt).rootTarget !== this) return;\n\n      PxMapBehavior.ElementImpl.shouldAddInst.call(this);\n      this.addInst();\n    },\n\n    canAddInst() {\n      if (typeof this.zoom !== 'undefined' && this._canBeNum(this.zoom) && this._afterFirstRender) {\n        return this.latLngIsValid(this.lat, this.lng, true);\n      }\n    },\n\n    createInst(options) {\n      const mapEl = Polymer.dom(this.root).querySelector('#map');\n      const mapInst = L.map(mapEl, options);\n\n      mapInst.attributionControl.setPrefix(options.attributionPrefix);\n\n      if (this.isShadyScoped()) {\n        mapInst.__addShadyScope = this.scopeSubtree.bind(this);\n      }\n      return mapInst;\n    },\n\n    addInst() {\n      // @TODO: This is a shim for browsers without shadow DOM. We need to\n      // re-append the `#map` element or it won't get the 'style-scope' CSS\n      // classes needed to style it or its children. That's bad. When the\n      // polyfill is updated or support is cut for browsers without shadow\n      // DOM, this should be removed.\n      if (this.isShadyScoped()) {\n        this.scopeSubtree(this.$.map, true);\n      }\n\n      // Bind custom events for the map intance. Events will be unbound automatically.\n      const mapMoveFn = this._handleMapMove.bind(this);\n      const zoomStartFn = this._handleZoomStart.bind(this);\n      const zoomEndFn = this._handleZoomEnd.bind(this);\n      this.bindEvents({\n        'moveend' : mapMoveFn,\n        'zoomstart' : zoomStartFn,\n        'zoomend' : zoomEndFn\n      });\n    },\n\n    removeInst() {\n      // Stop watching the shady root map element for changes\n      if (this.isShadyScoped()) {\n        this.scopeSubtree(this.$.map, false);\n      }\n    },\n\n    getInstOptions() {\n      const options = {};\n\n      // Static options\n      options.zoomControl = false;\n\n      // Dynamic options\n      options.crs = this.crs || L.CRS.EPSG3857;\n      options.center = [this.lat, this.lng];\n      options.zoom = this.zoom;\n      options.minZoom = this.minZoom || 0;\n      options.maxZoom = this.maxZoom || 18;\n      options.maxBounds = this.maxBounds || undefined;\n\n      options.dragging = !this.disableDragging;\n      options.scrollWheelZoom = !this.disableScrollZoom;\n      options.touchZoom = !this.disableTouchZoom;\n      options.doubleClickZoom = !this.disableDoubleClickZoom;\n      options.attributionControl = !this.disableAttribution;\n      options.attributionPrefix = this.attributionPrefix;\n\n      return options;\n    },\n\n    updateInst(lastOptions, nextOptions) {\n      if ((this.latLngIsValid(nextOptions.center[0], nextOptions.center[1])) &&\n          (lastOptions.center[0] !== nextOptions.center[0] ||\n          lastOptions.center[1] !== nextOptions.center[1] ||\n          lastOptions.zoom !== nextOptions.zoom)) {\n        this._updateMapView();\n      }\n\n      if (lastOptions.maxZoom !== nextOptions.maxZoom && !isNaN(nextOptions.maxZoom)) {\n        this.setMaxZoom(nextOptions.maxZoom);\n      }\n      if (lastOptions.minZoom !== nextOptions.minZoom && !isNaN(nextOptions.minZoom)) {\n        this.setMinZoom(nextOptions.minZoom);\n      }\n      if (lastOptions.maxBounds !== nextOptions.maxBounds && !isNaN(nextOptions.maxBounds)) {\n        this.setMaxBounds(nextOptions.maxBounds);\n      }\n\n      if (!lastOptions.dragging && nextOptions.dragging) {\n        this.elementInst.dragging.enable();\n      }\n      if (lastOptions.dragging && !nextOptions.dragging) {\n        this.elementInst.dragging.disable();\n      }\n\n      if (!lastOptions.scrollWheelZoom && nextOptions.scrollWheelZoom) {\n        this.elementInst.scrollWheelZoom.enable();\n      }\n      if (lastOptions.scrollWheelZoom && !nextOptions.scrollWheelZoom) {\n        this.elementInst.scrollWheelZoom.disable();\n      }\n\n      if (!lastOptions.touchZoom && nextOptions.touchZoom) {\n        this.elementInst.touchZoom.enable();\n      }\n      if (lastOptions.touchZoom && !nextOptions.touchZoom) {\n        this.elementInst.touchZoom.disable();\n      }\n\n      if (!lastOptions.doubleClickZoom && nextOptions.doubleClickZoom) {\n        this.elementInst.doubleClickZoom.enable();\n      }\n      if (lastOptions.doubleClickZoom && !nextOptions.doubleClickZoom) {\n        this.elementInst.doubleClickZoom.disable();\n      }\n\n      if (lastOptions.attributionPrefix !== nextOptions.attributionPrefix) {\n        this.elementInst.attributionControl.setPrefix(nextOptions.attributionPrefix);\n      }\n    },\n\n    /**\n     * Checks if the map container has changed size or visibility, and - if so -\n     * updates the map accordingly by refreshing the tile layer.\n     */\n    invalidateSize() {\n      if (!this.elementInst) return;\n\n      this.elementInst.invalidateSize();\n    },\n\n    /**\n     * Called when the `lat`, `lng`, or `zoom` properties are set or updated.\n     * Sets the map view to the new values.\n     */\n    _updateMapView() {\n      if (!this.elementInst) return;\n\n      this.debounce('update-map-view', function() {\n        const {lat, lng} = this.elementInst.getCenter();\n        const zoom = this.elementInst.getZoom();\n\n        if (this.lat !== lat || this.lng !== lng || this.zoom !== zoom) {\n          this.elementInst.setView([this.lat,this.lng], this.zoom);\n        }\n      });\n    },\n\n    /**\n     * Returns true if val can be used as a number in L.LatLng or zoom\n     *\n     * @param {*} val\n     * @return {Boolean}\n     */\n    _canBeNum(val) {\n      return (!isNaN(val) && val !== \"\");\n    },\n\n    /**\n     * Returns true if lat and lng are valid values that can be used to set a\n     * map's position. Prints an error if values are invalid (unless `hideError`\n     * is set to true).\n     *\n     * @param {Number} lat\n     * @param {Number} lng\n     * @param {Boolean} hideError\n     * @return {Boolean}\n     */\n    latLngIsValid(lat, lng, hideError) {\n      var isValid = (typeof lat !== 'undefined' && this._canBeNum(lat)) && (typeof lng !== 'undefined' && this._canBeNum(lng));\n      if (isValid) return true;\n      if (!hideError) {\n        console.log(`PX-MAP CONFIGURATION ERROR:\n          You entered an invalid \\`lat\\` or \\`lng\\` attribute for ${this.is}. You must pass a valid number.`);\n      }\n      return false;\n    },\n\n    /**\n     * Called when the map itself is moved (either by user interaction or by\n     * some other method programmatically setting geometry properties).\n     *\n     * Syncs the new lat, lng, and zoom to the map's properties and notifies\n     * out the result.\n     */\n    _handleMapMove() {\n      if (this.__isZooming) {\n        this.__onZoomEnd = this._handleMapMove.bind(this);\n        return;\n      }\n\n      this.debounce('handle-map-move', function() {\n        const latLng = this.elementInst.getCenter();\n        const zoom = this.elementInst.getZoom();\n        const bounds = this.elementInst.getBounds();\n\n        if (this.lat !== latLng.lat || this.lng !== latLng.lng) {\n          this.set('lat', latLng.lat);\n          this.set('lng', latLng.lng);\n        }\n        if (this.zoom !== zoom) {\n          this.set('zoom', zoom);\n        }\n\n        this.fire('px-map-moved', {\n          lat: latLng.lat,\n          lng: latLng.lng,\n          zoom: zoom,\n          bounds: bounds\n        });\n      });\n    },\n    /**\n     * Fired when the map's centerpoint (lat/lng) or zoom is changed by the user\n     * or programatically.\n     *\n     *   * {Object} detail - Contains the event details\n     *   * {Number} detail.lat - Latitude of the map centerpoint after moving\n     *   * {Number} detail.lng - Longitude of the map centerpoint after moving\n     *   * {Number} detail.zoom - Zoom level of the map after moving\n     *   * {L.LatLngBounds} detail.bounds - Custom Leaflet object describing the visible bounds of the map as a rectangle\n     *\n     * @event px-map-moved\n     */\n\n     /**\n      * Sets an internal boolean that allows us to wait before handling any map\n      * movements until the zoom animation is over.\n      */\n    _handleZoomStart() {\n      this.__isZooming = true;\n    },\n\n    /**\n     * Sets an internal boolean that allows us to wait before handling any map\n     * movements until the zoom animation is over.\n     */\n    _handleZoomEnd() {\n      this.__isZooming = false;\n      if (typeof this.__onZoomEnd === 'function') {\n        this.__onZoomEnd();\n        this.__onZoomEnd = null;\n      }\n    },\n\n    /**\n     * Iterates over all markers attached to the map and returns an array of markers\n     * that are within the visible bounds. Use to discover which markers the\n     * user can currently see and change/filter the state of your app.\n     *\n     * This is an expensive operation, particularly for maps with many markers\n     * (e.g. in a marker group). Only call it when necessary.\n     *\n     * To get continuous updates on which markers are visible, attach a\n     * `px-map-moved` event listener to this element and call this method\n     * after each moved event.\n     *\n     * @return {Array}\n     */\n    getVisibleMarkers() {\n      const mapBounds = this.elementInst.getBounds();\n      let markers = [];\n\n      // Loop over the layers\n      this.elementInst.eachLayer((layer) => {\n        // Most markers should have an `isMarker` static property defined as `true`\n        // and a `getLatLng` method\n        if (layer.isMarker && layer.getLatLng) {\n          // Only push markers that are visible\n          if (mapBounds.contains(layer.getLatLng()) && markers.indexOf(layer) === -1) {\n            markers.push(layer);\n          }\n        }\n\n        // Marker clusters have a `_markerCluster` key\n        if (layer._markerCluster) {\n          layer.eachLayer((marker) => {\n            // Only push markers that are visible\n            let parentCluster = layer.getVisibleParent(marker);\n            if (parentCluster && mapBounds.contains(parentCluster.getLatLng()) && marker && markers.indexOf(marker) === -1) {\n              markers.push(marker);\n            }\n          })\n        }\n      });\n\n      return markers;\n    }\n  };\n  /* Bind Popup behavior */\n  /** @polymerBehavior */\n  PxMapBehavior.LeafletRoot = [\n    PxMapBehavior.Element,\n    PxMapBehavior.ParentLayer,\n    PxMapBehavior.LeafletRootImpl,\n    PxMapBehavior.TrackMarkersImpl\n  ];\n})();\n"]}