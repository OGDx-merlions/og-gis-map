{"version":3,"sources":["og-gis-map.es6.js"],"names":["Polymer","is","properties","width","type","String","value","height","crs","Object","lat","Number","notify","lng","zoom","maxZoom","minZoom","maxBounds","Array","tileUrl","features","featureStyle","markerGroups","colorsByType","regions","observer","clusterConfig","hasRegions","Boolean","computed","_hasRegions","length","_focusRegion","evt","eventDetail","detail","selected","item","key","$","map","_selectDefaultRegion","regionsDropdownData","forEach","_region","idx","obj","val","label","default","push"],"mappings":"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","file":"og-gis-map.js","sourcesContent":["(function() {\n  Polymer({\n\n    is: 'og-gis-map', \n\n    properties: {\n      /**\n       * Component width\n       */\n      width: {\n        type: String,\n        value: '75vw'\n      },\n      /**\n      * Component Height\n      */\n      height: {\n        type: String,\n        value: '500px'\n      },\n      /**\n       * The coordinate reference system to use when projecting geographic points\n       * into pixel coordinates. Can only be set once before the map is first\n       * initialized. If you don't know what this is, do not set it and the map\n       * will default to the most common web mapping projection (EPSG3857).\n       *\n       * @type {L.CRS}\n       */\n      crs: {\n        type: Object\n      },\n      /**\n       * The latitude of the active map center. Can be used to set or update\n       * the center of the map, or read from after the user moves the map to\n       * get updated coordinates.\n       * \n       * When `regions` is specified, latitude and longitude may be picked from there.\n       * So avoid providing both\n       *\n       * @type {Number}\n       */\n      lat: {\n        type: Number,\n        notify: true\n      },\n      /**\n       * The longitude of the active map center. Can be used to set or update\n       * the center of the map, or read from after the user moves the map to\n       * get updated coordinates.\n       * \n       * When `regions` is specified, latitude and longitude may be picked from there.\n       * So avoid providing both\n       * \n       * @type {Number}\n       */\n      lng: {\n        type: Number,\n        notify: true\n      },\n\n      /**\n       * The zoom level of the active map. Can be used to set or update\n       * the zoom level of the map, or read from after the user changes the\n       * map zoom level to an updated value.\n       *\n       * @type {Number}\n       */\n      zoom: {\n        type: Number,\n        value: 10\n      },\n\n      /**\n       * The maximum zoom level for the active map (the furthest the user can\n       * zoom in). Setting it at the map level will take precedence over the\n       * max zoom of all other layers, including tile layers. If you need to\n       * set different zoom bounds based on the visible tile layer, set the\n       * max zoom directly on your tile layer.\n       *\n       * @type {Number}\n       */\n      maxZoom: {\n        type: Number\n      },\n\n      /**\n      * The minimum zoom level for the active map (the furthest the user can\n      * zoom out). Setting it at the map level will take precedence over the\n      * min zoom of all other layers, including tile layers. If you need to\n      * set different zoom bounds based on the visible tile layer, set the\n      * min zoom directly on your tile layer.\n       *\n       * @type {Number}\n       */\n      minZoom: {\n        type: Number\n      },\n\n      /**\n       * Restricts the user from moving the map outside of a specific geographic\n       * boundary. The user will be bounced back if they attempt to pan outside the view.\n       * Disabled by default, letting the user pan to any point on the map.\n       *\n       * Pass an array of [lat,lng] values like the following:\n       *\n       *        [[40.712, -74.227], [40.774, -74.125]]\n       *\n       * The first pair should represent the southwest extend of the boundary,\n       * and the second  pair should represent the northeast extend of the\n       * boundary.\n       *\n       * @type {Array}\n       */\n      maxBounds: {\n        type: Array\n      },\n      /**\n       * A template string that will be converted into a URL used to call the tile\n       * service. Should be in the following format:\n       *\n       *    `http://{s}.somedomain.com/blabla/{z}/{x}/{y}.png`\n       *\n       * The following values will be substituted for letters in `{}` brackets:\n       *\n       * - `{s}`: a subdomain to call to allow the browser to make many parallel requests\n       * - `{z}`: the map zoom level\n       * - `{x}` and `{y}`: the coordinates for the tile\n       *\n       * @type {String}\n       */\n      tileUrl: {\n        type: String,\n        value: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'\n      },\n      /**\n       * An object formatted as a GeoJSON FeatureCollection with one or more Features.\n       * Each feature can be formatted as any valid GeoJSON geometry type: Point,\n       * LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon,\n       * or GeometryCollection. See the [GeoJSON spec](http://geojson.org/geojson-spec.html)\n       * for guidance on generating valid GeoJSON.\n       *\n       * Each feature should contain a `properties` object that can hold metadata\n       * about the feature. Optionally, the feature's `properties.style` can be\n       * set to an object that will be used to style the feature when it is drawn.\n       * Styles set in a feature's `properties.style` will override the styles\n       * set in the `featureStyle` attribute. See the `featureStyle` attribute\n       * documentation for a list of available style options.\n       *\n       * @type {Object}\n       */\n      features: {\n        type: Object,\n        value() {\n          return {};\n        }\n      },\n      /**\n       * An object with settings that will be used to style each feature when\n       * it is added to the map. The following options are available:\n       *\n       * - {Boolean} `stroke`: [default=true] Set to false to disable borders on polygons/circles\n       * - {String} `color`: [default=$primary-blue] Color for polygon/circle borders\n       * - {Number} `weight`: [default=2] Weight for polygon/circle borders in pixels\n       * - {Number} `opacity`: [default=1.0] Opacity for polygon/circle borders\n       * - {Boolean} `fill`: [default=true] Set to false to disable filling polygons/circles\n       * - {String} `fillColor`: [default=$dv-light-blue] Color for polygon/circle fill\n       * - {Number} `fillOpacity`: [default=0.4] Opacity for polygon/circle fill\n       * - {String} `fillRule`: [default='evenodd'] Defines how the [inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined\n       * - {String} `lineCap`: [default='round'] Defines the [shape to be used](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) at the end of the stroke\n       * - {String} `lineJoin`: [default='round'] Defines the [shape to be used](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) at the corner of a stroke\n       * - {String} `dashArray`: [default=null] Defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray)\n       * - {String} `dashOffset`: [default=null] Defines the [distance into the dash to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset)\n       *\n       * Note that styles can also be added to each feature individually (see\n       * the `data` attribute documentation). Styles defined on each feature will\n       * override the `featureStyle`.\n       *\n       * @type {Object}\n       */\n      featureStyle: {\n        type: Object,\n        value() {\n          return {};\n        }\n      },\n      /**\n       * An array of objects formatted as a GeoJSON FeatureCollection with one or many Features.\n       * Each feature should be a point that will be represented as a marker.\n       * See the `px-map-marker-group` API documentation page for an in-depth\n       * guide that explains how to configure your features.\n       *\n       * The root feature collection object must have the following keys/values:\n       *\n       * - {String} `type`: Must be 'FeatureCollection'\n       * - {Array}  `features`: An array of feature objects\n       *\n       * Each feature object in the collection must have the following key/values:\n       *\n       * - {String} `type`: Must be 'Feature'\n       * - {Number} `id`: A unique numeric ID. If the feature is changed, it should keep its ID. No other features in the collection should have the same ID.\n       * - {Object} `geometry`\n       * - {String} `geometry.type`: Must be 'Point'\n       * - {Array}  `geometry.coordinates`: a pair of coordinates in `[lng,lat]` order\n       * - {Object} `properties`\n       * - {Object} `properties.marker-icon`: Settings to configure a marker icon\n       * - {Object} `properties.marker-popup`: [OPTIONAL] Settings to configure a marker icon\n       *\n       * @type {Object}\n       */\n      markerGroups: {\n        type: Array,\n        value() {\n          return [];\n        }\n      },\n      /**\n       * An object mapping categories of icons to their respective colors. Each\n       * key should be a string representing the name of an `icon-type` to\n       * a valid CSS color value (e.g. hex color, `rgb()` color). Set the\n       * `icon-type` as a sub-property of `properties.marker-icon` for each marker\n       * feature in the FeatureCollection you pass into the `data` attribute.\n       *\n       * By default, the available types are:\n       * - \"unknown\" : \"--px-map-icon-unknown-color\" (default: gray)\n       * - \"info\" : \"--px-map-icon-info-color\" (default: blue)\n       * - \"warning\" : \"--px-map-icon-warning-color\" (default: orange)\n       * - \"important\" : \"--px-map-icon-important-color\" (default: red)\n       * - \"custom-n\" : \"--px-map-color-custom-n\" (default: n/a)\n       *\n       * Example #1 - `colorsByType` object\n       *\n       * ```\n       * {\n       *   \"info\" : \"blue\",\n       *   \"warning\" : \"orange\",\n       *   \"important\" : \"red\",\n       *   \"unknown\" : \"gray\"\n       * }\n       * ```\n       *\n       * Example #2 - `colorsByType` object with custom types\n       *\n       * ```\n       * {\n       *   \"info\" : \"blue\",\n       *   \"custom-0\" : \"salmon\",\n       *   \"custom-1\" : \"lime\",\n       *   \"custom-2\" : \"crimson\"\n       * }\n       * ```\n       *\n       * @type {Object}\n       */\n      colorsByType: {\n        type: Object,\n        value(){\n          return {};\n        }\n      },\n      /**\n       * List of Regions in the map. Will be rendered in the button overlay.\n       * Clicking on the region will move the focus to the specific \n       * latitude and longitude in the map.\n       * \n       * Format: [{label: \"Region 1\", lat: 100, lng: 0, default: true}, {label: \"Region 2\", lat: -100, lng: 0}]\n       * @type {Array}\n       */\n      regions: {\n        type: Array,\n        value() {\n          return []\n        },\n        observer: '_selectDefaultRegion'\n      },\n      /**\n       * Allows advanced configurations of the cluster behaviors and styles. Note\n       * that the cluster comes pre-configured with settings that will work\n       * for most use cases; the `clusterConfig` allows those settings to be\n       * overriden but may cause unexpected behaviors when conflicting settings\n       * are used. Leave the default configuration (by not setting this attribute)\n       * if you're unsure of how to use it.\n       *\n       * The following settings are available:\n       *\n       * - {Boolean} `showCoverageOnHover`: [default=true] Shows the bounds of a cluster as a polygon when its icon is hovered\n       * - {Boolean} `zoomToBoundsOnClick`: [default=true] Zooms to bounds of a cluster when its icon is clicked\n       * - {Boolean} `spiderfyOnMaxZoom`: [default=true] Spiderfies the markers in a cluster when it is clicked at the max zoom level\n       * - {Boolean} `removeOutsideVisibleBounds`: [default=true] Removes cluster icons and markers when they are too far outside the visible map bounds\n       * - {Boolean} `animate`: [default=true] Animates cluster splitting, joining, zooming, and spiderfying\n       * - {Number} `disableClusteringAtZoom`: [default=undefined] If set, when the user zooms below this level markers will not be clustered (do not combine with `spiderfyOnMaxZoom`)\n       * - {Number} `maxClusterRadius`: [default=150] The maximum radius in pixels a cluster will cover from the central marker. Lower numbers make smaller clusters. Setting below the default may cause cluster icons to overlap.\n       * - {Object} `polygonOptions`: [default=150] Options passed to draw the cluster cover polygon\n       *   - {Boolean} `polygonOptions.stroke`: [default=true] If true the polygon will have a stroke line around the outside\n       *   - {String} `polygonOptions.color`: [default=--px-map-marker-group-cluster-polygon-stroke-color] Sets the stroke color, prefer setting with the style variable\n       *   - {String} `polygonOptions.fillColor`: [default=--px-map-marker-group-cluster-polygon-fill-color] Sets the fill color color, prefer setting with the style variable.\n       *   - {Number} `polygonOptions.fillOpacity`: [default=0.4] Sets the opacity of the polygon fill\n       * - {Object} `spiderLegPolylineOptions`: [default=undefined] Sets the style for the marker spiderfy legs, see [PolylineOptions](http://leafletjs.com/reference.html#polyline-options)\n       *\n       * @type {Object}\n       */\n      clusterConfig: {\n        type: Object,\n        value() {\n          return {}\n        }\n      },\n      hasRegions: {\n        type: Boolean,\n        computed: '_hasRegions(regions)',\n        value() {\n          return []\n        }\n      }\n    },\n\n    _hasRegions(regions){\n      return regions && regions.length;\n    },\n    _focusRegion(evt) {\n      let eventDetail = evt.detail;\n      if(eventDetail.selected) {\n        let item = this.regions[eventDetail.key];\n        this.lat = item.lat;\n        this.lng = item.lng;\n        this.$.map.zoom = item.zoom || this.zoom;\n      }\n    },\n    _selectDefaultRegion() {\n      this.regionsDropdownData = [];\n      if(this.regions) {\n        this.regions.forEach((_region, idx) => {\n          let obj = _region;\n          obj.key = idx;\n          obj.val = _region.label\n          if(_region.default) {\n            this.lat = _region.lat;\n            this.lng = _region.lng;\n            obj.selected = true;\n          }\n          this.regionsDropdownData.push(obj);\n        });\n      }\n    }\n  });\n})();\n"]}